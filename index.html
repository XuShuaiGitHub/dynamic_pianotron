<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>高级虚拟电子钢琴 - 跳动音符效果</title>
    <style>
      :root {
        --theme-color: #ee479a;
        --theme-gradient: linear-gradient(45deg, #ff69b4, #ff3366);
      }

      body {
        font-family: Arial, sans-serif;
        text-align: center;
        margin: 0;
        overflow: hidden;
      }

      h1 {
        margin-bottom: 10px;
      }

      .controls {
        position: relative;
        z-index: 2;
        margin: 20px auto;
      }

      .controls > div:first-of-type {
        margin-bottom: 10px;
      }

      .controls button {
        padding: 8px 12px;
        margin: 0 5px;
        font-size: 14px;
        background: rgba(255, 255, 255, 0.9);
        border: 2px solid var(--theme-color);
        border-radius: 20px;
        transition: all 0.3s;
      }

      .controls #current-octave,
      .controls #current-transpose {
        color: white;
        margin: 0 5px;
      }

      .controls button:hover {
        background: var(--theme-color);
        color: white;
        transform: translateY(-2px);
      }

      .piano-container {
        position: relative;
        width: 480px;
        height: 200px;
        margin: 0 auto;
        z-index: 2; /* 高于Canvas */
        background: rgba(255, 255, 255, 0.8); /* 半透明白底 */
        backdrop-filter: blur(5px); /* 毛玻璃效果 */
      }

      .piano {
        position: relative;
        width: 480px;
        height: 200px;
      }

      .key {
        position: absolute;
        border: 1px solid #000;
        cursor: pointer;
        user-select: none;
      }

      .white {
        width: 60px;
        height: 200px;
        background: white;
        z-index: 1;
      }

      .black {
        width: 40px;
        height: 120px;
        background: black;
        z-index: 2;
        color: #fff;
      }

      .key.active.white {
        background: linear-gradient(45deg, #fff5f5, #ffecec);
        box-shadow: inset 0 0 15px #ffb6c1;
      }
      .key.active.black {
        background: #555;
      }

      .black.active::after {
        content: "";
        position: absolute;
        top: 0;
        left: -10px;
        width: 140%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent 20%,
          rgba(255, 182, 193, 0.6) 50%,
          transparent 80%
        );
        animation: blackShine 0.4s;
      }

      @keyframes blackShine {
        from {
          left: -10px;
        }
        to {
          left: 100%;
        }
      }

      .instructions {
        margin-top: 30px;
        text-align: left;
        max-width: 480px;
        margin-left: auto;
        margin-right: auto;
        background: #fff;
        padding: 15px;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      #fireworks-canvas {
        position: fixed;
        top: 0;
        left: 0;
        pointer-events: none;
        z-index: 1;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <div>
        <button id="octave-down">八度 -1</button>
        <button id="octave-up">八度 +1</button>
        <span id="current-octave">当前基准八度: 4</span>
      </div>
      <div>
        <button id="transpose-down">转调 -1</button>
        <button id="transpose-up">转调 +1</button>
        <span id="current-transpose">当前转调: 0</span>
      </div>
    </div>

    <div class="piano-container">
      <div class="piano">
        <!-- 白键 -->
        <div class="key white" data-key="a" style="left: 0px">a</div>
        <div class="key white" data-key="s" style="left: 60px">s</div>
        <div class="key white" data-key="d" style="left: 120px">d</div>
        <div class="key white" data-key="f" style="left: 180px">f</div>
        <div class="key white" data-key="g" style="left: 240px">g</div>
        <div class="key white" data-key="h" style="left: 300px">h</div>
        <div class="key white" data-key="j" style="left: 360px">j</div>
        <div class="key white" data-key="k" style="left: 420px">k</div>

        <!-- 黑键 -->
        <div class="key black" data-key="w" style="left: 40px">w</div>
        <div class="key black" data-key="e" style="left: 100px">e</div>
        <div class="key black" data-key="t" style="left: 220px">t</div>
        <div class="key black" data-key="y" style="left: 280px">y</div>
        <div class="key black" data-key="u" style="left: 340px">u</div>
      </div>
    </div>

    <!-- 浮动音符显示区域 -->
    <div id="notes-container"></div>

    <!-- <div class="instructions">
      <h2>键盘映射（当前基准八度和转调会影响实际音高）</h2>
      <ul>
        <li>a: C</li>
        <li>w: C#</li>
        <li>s: D</li>
        <li>e: D#</li>
        <li>d: E</li>
        <li>f: F</li>
        <li>t: F#</li>
        <li>g: G</li>
        <li>y: G#</li>
        <li>h: A</li>
        <li>u: A#</li>
        <li>j: B</li>
        <li>k: C（高于其他键一个八度）</li>
      </ul>
      <p>
        通过“提高八度/降低八度”和“转调”按钮，你可以调整基准音域。每次按键触发后，还会出现一个跳动的音符动画，让交互更生动。
      </p>
      <h2>以钢琴曲《欢乐颂》为例，其演奏乐谱为：</h2>
      <ul>
        <li>小节1（3 3 4 5）：按键顺序 → d, d, f, g</li>
        <li>小节2（5 4 3 2）：按键顺序 → g, f, d, s</li>
        <li>小节3（1 1 2 3）：按键顺序 → a, a, s, d</li>
        <li>小节4（3 2 2 -）：按键顺序 → d, s, s</li>
        <li>小节5（3 3 4 5）：按键顺序 → d, d, f, g</li>
        <li>小节6（5 4 3 2）：按键顺序 → g, f, d, s</li>
        <li>小节7（1 1 2 3）：按键顺序 → a, a, s, d</li>
        <li>小节8（2 1 1 -）：按键顺序 → s, a, a</li>
      </ul>
    </div> -->

    <!-- 在body末尾添加canvas元素 -->
    <canvas id="fireworks-canvas"></canvas>

    <script>
      // 定义各自然音相对于C的半音偏移
      const noteOffsets = {
        C: 0,
        "C#": 1,
        D: 2,
        "D#": 3,
        E: 4,
        F: 5,
        "F#": 6,
        G: 7,
        "G#": 8,
        A: 9,
        "A#": 10,
        B: 11,
      };

      // 键盘映射，每个键映射到音符和相对于基准八度的偏移
      const keyMap = {
        a: { note: "C", octaveOffset: 0 },
        w: { note: "C#", octaveOffset: 0 },
        s: { note: "D", octaveOffset: 0 },
        e: { note: "D#", octaveOffset: 0 },
        d: { note: "E", octaveOffset: 0 },
        f: { note: "F", octaveOffset: 0 },
        t: { note: "F#", octaveOffset: 0 },
        g: { note: "G", octaveOffset: 0 },
        y: { note: "G#", octaveOffset: 0 },
        h: { note: "A", octaveOffset: 0 },
        u: { note: "A#", octaveOffset: 0 },
        j: { note: "B", octaveOffset: 0 },
        k: { note: "C", octaveOffset: 1 }, // “k”键代表高一个八度的C
      };

      let baseOctave = 4;
      let transpose = 0;

      function updateDisplay() {
        document.getElementById(
          "current-octave"
        ).textContent = `当前基准八度: ${baseOctave}`;
        document.getElementById(
          "current-transpose"
        ).textContent = `当前转调: ${transpose}`;
      }

      // 计算音符频率：f = 440 × 2^((effectiveSemitone)/12)
      function getFrequency(note, octave) {
        const semitoneDiff =
          (octave - 4) * 12 +
          (noteOffsets[note] - noteOffsets["A"]) +
          transpose;
        return 440 * Math.pow(2, semitoneDiff / 12);
      }

      // 播放音符
      const audioContext = new (window.AudioContext ||
        window.webkitAudioContext)();
      let oscillator;

      function playNote(note, octave) {
        oscillator?.stop();
        const freq = getFrequency(note, octave);
        oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        const safeFreq = Math.max(
          0.0001,
          Math.min(96000, Number.isFinite(freq) ? freq : 440)
        ); // 强制限定有效范围
        oscillator.frequency.value = Math.fround(safeFreq); // 解决精度问题
        oscillator.type = "sine";

        const now = audioContext.currentTime;
        gainNode.gain.cancelScheduledValues(now);
        // 在当前时间立即将增益值设为0，即音量为0
        gainNode.gain.setValueAtTime(0, now);
        // 在0.1秒内使增益值线性上升到1
        gainNode.gain.linearRampToValueAtTime(1, now + 0.1);
        // now+0.5秒后，将增益设置为1
        gainNode.gain.setValueAtTime(1, now + 0.5);
        // 在 now+0.45 到 now+0.7 之间，使增益值线性下降到0
        gainNode.gain.linearRampToValueAtTime(0, now + 0.7);

        oscillator.start(now);
        oscillator.stop(now + 0.7);
      }

      // 烟花系统核心实现
      class Firework {
        constructor({ startX, hue, targetY, speed }) {
          this.x = startX;
          this.y = window.innerHeight + 50; // 从屏幕底部外开始
          this.targetY = targetY || window.innerHeight * 0.7; // 精确到屏幕可视区域的一定高度（非文档总高度）
          this.speed = speed || 18; // 提升初始速度
          this.radius = 5; // 增大上升光球尺寸
          this.hue = hue || Math.random() * 50 + 280; // 粉色系
          this.particles = [];
          this.exploded = false;
        }

        update() {
          if (!this.exploded) {
            this.y -= this.speed * 0.98; // 添加速度衰减

            // 双重高度验证（防止溢出屏幕顶部）
            const isOverTarget = this.y <= this.targetY;
            const isOverTop = this.y <= 0;
            if (isOverTarget || isOverTop) {
              this.explode();
            }
          }

          this.particles.forEach((p) => p.update());
          this.particles = this.particles
            .filter((p) => p.opacity > 0.1)
            .slice(0, 300); // 性能优化
        }

        explode() {
          this.exploded = true;
          for (let i = 0; i < 100; i++) {
            this.particles.push(
              new Particle(this.x, this.y, Math.PI * 2 * (i / 100), this.hue)
            );
          }
        }

        draw(ctx) {
          // 绘制上升轨迹
          if (!this.exploded) {
            // 创建轨迹渐变
            const gradient = ctx.createLinearGradient(
              this.x,
              window.innerHeight,
              this.x,
              this.y
            );
            gradient.addColorStop(0, `hsla(${this.hue}, 80%, 60%, 0.7)`);
            gradient.addColorStop(1, `hsla(${this.hue}, 80%, 70%, 0.3)`);

            // 绘制加宽轨迹（动态线宽）
            ctx.beginPath();
            ctx.moveTo(this.x, window.innerHeight);
            ctx.lineTo(this.x, this.y);
            ctx.lineWidth = Math.max(8 * (1 - this.y / this.targetY), 4); // 动态宽度计算
            ctx.strokeStyle = gradient;
            ctx.stroke();

            // 绘制发光核心
            ctx.beginPath();
            ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(60, 80%, 70%, 0.9)`;
            ctx.fill();
          }

          // 绘制爆炸粒子
          this.particles.forEach((p) => {
            p.draw(ctx);
            // 粒子拖尾光晕
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${p.hue}, 60%, 50%, ${p.opacity * 0.3})`;
            ctx.fill();
          });
        }
      }

      class Particle {
        constructor(x, y, angle, hue) {
          this.x = x;
          this.y = y;
          this.angle = angle + (Math.random() - 0.5) * 1.2;
          this.velocity = Math.random() * 8 + 5;
          this.gravity = 0.5; // 加大重力
          this.friction = 0.91; // 减少空气阻力
          this.hue = hue + Math.random() * 60 - 20; // 色相波动
          this.size = Math.random() * 3 + 1;
          this.opacity = 1;
        }

        update() {
          this.velocity *= this.friction;
          this.x += Math.cos(this.angle) * this.velocity;
          this.y += Math.sin(this.angle) * this.velocity + this.gravity;
          this.opacity -= 0.013; // 减缓消失速度
        }

        draw(ctx) {
          // 添加发光效果
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
          ctx.fillStyle = `hsla(${this.hue}, 80%, 50%, ${this.opacity * 0.3})`;
          ctx.fill();

          // 核心粒子
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fillStyle = `hsla(${this.hue}, 80%, 70%, ${this.opacity})`;
          ctx.fill();
        }
      }

      // 烟花系统控制器
      class FireworksSystem {
        constructor() {
          this.fireworks = []; // 初始化烟花粒子
          this.stars = []; // 初始化星星数组
          // 频率映射参数
          this.minFreq = 130.81; // C3 (最低音)
          this.maxFreq = 2093.0; // C7 (最高音)
          this.heightRange = [0.5, 0.9]; // 屏幕高度比例范围 [最高音位置, 最低音位置]

          this.canvas = document.getElementById("fireworks-canvas");
          this.ctx = this.canvas.getContext("2d");
          this.resize();
          window.addEventListener("resize", () => this.resize());

          // 在琴键事件绑定中传递频率
          document.querySelectorAll(".key").forEach((keyElement) => {
            keyElement.addEventListener("mousedown", () => {
              const rect = keyElement.getBoundingClientRect();
              const key = keyElement.getAttribute("data-key");
              const { note, octaveOffset } = keyMap[key];
              const effectiveOctave = baseOctave + octaveOffset;
              const frequency = getFrequency(note, effectiveOctave);
              fireworks.launch(rect.left + rect.width / 2, frequency);
            });
          });

          this.animate();
        }

        // 初始化星空
        initStars(count) {
          for (let i = 0; i < count; i++) {
            this.stars.push({
              x: Math.random() * this.canvas.width,
              y: Math.random() * this.canvas.height,
              size: Math.random() * 1.5 + 0.5,
              alpha: Math.random() * 0.5 + 0.5,
              speed: Math.random() * 0.02 + 0.01,
            });
          }
        }

        // 绘制星空背景
        drawBackground() {
          // 创建深空渐变背景
          const gradient = this.ctx.createRadialGradient(
            this.canvas.width / 2,
            this.canvas.height / 2,
            0,
            this.canvas.width / 2,
            this.canvas.height / 2,
            Math.max(this.canvas.width, this.canvas.height)
          );
          gradient.addColorStop(0, "#0a0a2a");
          gradient.addColorStop(1, "#000000");

          this.ctx.fillStyle = gradient;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // 绘制闪烁星星
          this.stars.forEach((star) => {
            star.alpha += star.speed;
            if (star.alpha > 1 || star.alpha < 0.3) star.speed *= -1;

            this.ctx.beginPath();
            this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            this.ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
            this.ctx.fill();
          });
        }

        resize() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
          this.initStars(200); // 重置星星位置
        }

        launch(x, frequency) {
          // 标准化频率到高度比例
          const normalized =
            (Math.log2(frequency) - Math.log2(this.minFreq)) /
            (Math.log2(this.maxFreq) - Math.log2(this.minFreq));
          const targetYRatio =
            this.heightRange[0] +
            (1 - normalized) * (this.heightRange[1] - this.heightRange[0]);

          const firework = new Firework({
            startX: x,
            hue: Math.random() * 360, // 全色域随机
            targetY: window.innerHeight * targetYRatio, // 频率越高Y值越小（位置更高）
            speed: 18 + normalized * 10, // 高频音符速度更快
          });

          this.fireworks.push(firework);
        }

        animate() {
          // 先清空画布
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // 先绘制星空背景
          this.drawBackground();

          // 添加尾迹效果
          this.ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          this.fireworks.forEach((firework) => {
            firework.update();
            firework.draw(this.ctx);
          });

          // 自动清理
          this.fireworks = this.fireworks.filter(
            (f) => !f.exploded || f.particles.length > 0
          );

          requestAnimationFrame(() => this.animate());
        }
      }

      // 琴键点击事件
      document.querySelectorAll(".key").forEach((keyEl) => {
        keyEl.addEventListener("click", () => {
          const key = keyEl.getAttribute("data-key");
          if (keyMap[key]) {
            const { note, octaveOffset } = keyMap[key];
            const effectiveOctave = baseOctave + octaveOffset;
            playNote(note, effectiveOctave);
            keyEl.classList.add("active");
            setTimeout(() => {
              keyEl.classList.remove("active");
            }, 200);
          }
        });
      });

      // 键盘事件监听
      document.addEventListener("keydown", (event) => {
        const key = event.key.toLowerCase();
        if (keyMap[key]) {
          const { note, octaveOffset } = keyMap[key];
          const effectiveOctave = baseOctave + octaveOffset;
          playNote(note, effectiveOctave);
          const keyElement = document.querySelector(`.key[data-key="${key}"]`);
          if (keyElement) {
            keyElement.classList.add("active");
            setTimeout(() => {
              keyElement.classList.remove("active");
            }, 200);
          }
        }
      });

      // 控制面板按钮
      document.getElementById("octave-up").addEventListener("click", () => {
        baseOctave++;
        updateDisplay();
      });
      document.getElementById("octave-down").addEventListener("click", () => {
        baseOctave--;
        updateDisplay();
      });
      document.getElementById("transpose-up").addEventListener("click", () => {
        transpose++;
        updateDisplay();
      });
      document
        .getElementById("transpose-down")
        .addEventListener("click", () => {
          transpose--;
          updateDisplay();
        });

      // 初始化音调显示
      updateDisplay();

      // 初始化烟花系统
      const fireworks = new FireworksSystem();
    </script>
  </body>
</html>
